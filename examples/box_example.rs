/*

Преимущества и недостатки стека и кучи

Часто у новичков возникает вопрос - зачем нужен Box, если есть стек. Боксовый обьект удаляется,
когда Box удаляется. В чем смысл? Просто храним в стеке - и все!

Обьясняю.

Кратко. Используем Кучу если:
    1. Размер обьекта неизвестен на этапе компиляции
    2. Размер обьекта настлько большой, что хочется избежать лишних его копирований.
    3. требуется порядок удаления обьектов отличный от порядка, обратного тому, в котором
    обьекты создавали (с некоторыми оговорками)
    4. Если обьект настолько большой, что в стек просто не помещается.
    5. Если копирований хочется избежать полностью. Чтобы обьект лежал всегда по одному адресу

Теперь Подробней.

1. Размер хранимого обьекта

В rust (как и в си и в си++) в стеке можно хранить только те типы, размер которых постоянен
и известен на момент компиляции. Если размер типа неизвестен на этапе компиляции - в
стеке его хранить не получится. Компилятор не даст. В раст такими типами являются трейт-обьекты,
векторы, мапы и прочие коллекции и тд.

Таким образом,
* Vec<T> имеет внутри себя Box
* чтобы создать трейт и передать (а так же возвратить) его по
    значению - понадобится Box (см.пример 1)


2. Большие обьекты

Как известно, когда мы обьект присваиваем, он или копируется (если для него реализован типаж Copy),
или переносится. Но это - с лексической точки зрения. На самом деле, после компиляции получается
копирование участка памяти из одного места в другое. Это происходит каждый раз на вызове функции,
на присваиваниях/перемещениях, на возврате значения из функций. Ттут надо сказать, что нередко
компилятор может оптимизировать часть копирований - но не все.
Проблемы могут начаться, когда мы оперируем большими обьектами. Наприер, массивом
в 1мб: [u8; 1024*1024]. Каждый раз при передаче, присваивании и тд этот массив будет копироваться,
и копирование больших участков памяти будет тормозить. Решение - обернуть это в Box, и оперировать
Box<[u8; 1024*1024]>. Технически, Box - это указатель в кучу, обычно размер
указателя - 8 или 4 байта (в зависимости от архитектуры). Вот эти 8 или 4 байта и будут копироваться.
это совсем не то, что копировать каждый раз 1мб. (см. пример 2)


3. Пордок создания и удаления

Стек реализован аппаратно, работает он быстро, но у него есть недостаток - удаление обьектов
проиходит в порядке обратном по отношению к созданию.

Куча реализована програмно, работает медленней - но порядок удаления можно сделать любым.

Вопрос новичка звучит так: как работает стек и как работает куча? - см файл stack_and_heap.txt

Вопрос новичка звучит так: есть ли пример, в котором написать код, используя стек
без изворотов, никак не получится?
Ответ: любая сколь-нибудь реальная программа скорей всего использует кучу и стек.
см. пример 3
см. пример 4

Примечание. На самом деле, строго говоря, порядок удаления не всегда тот, в котором обьекты создавались.
Например, если наполнить [Option<T>; 10] обьектами - то они будут удаляться в неизвестном порядке.
Но все равно, это близко к порядку обратному по отношению к созданию.


4. Очень большие обьекты

Обычно каждая операционная система под стек отводит не очень большой размер памяти. В линуксе что-то
около 8мб по умолчанию, например. Создать в стеке обьект больше, чем отводит ОС, не получится.
В этом случае куча - единственно возможный вариант
например:

fn main() {
    let obuf: [u8; 20000000] = [0; 20000000];
    println!("{}", obuf[0]);
}

скомпилируется:
$ rustc -o test2 test2.rs

Но при попытке запустить она упадет с ошибкой:
$ ./test2

thread 'main' has overflowed its stack
fatal runtime error: stack overflow
Aborted (core dumped)



5. Если копирований хочется избежать полностью. Чтобы обьект лежал всегда по одному адресу

Иногда нужно полностью избежать копирований (и перемещений) обьекта. Тогда легче, к приемру,
оперировать сырыми ссылками. Например, можно создать обьект, и возвратить сырой указатель на него.
Что-то в этом роде.

*/


//-------------------------- пример 1 ---------------------
struct Foo {}

trait MyCoolTrait {
    fn some_func(&self);
}


impl MyCoolTrait for Foo {
    fn some_func(&self){}
}


fn cool_func(){
    // создать и передеать трейт
    let foo= Box::new(Foo{});
    cool_func2(foo);
}

fn cool_func2(v: Box<MyCoolTrait>){

}

fn cool_func3()->Box<MyCoolTrait> {
    // возвратить трейт
    Box::new(Foo{})
}

fn demo_slice(len: usize){
    let mut s:Vec<usize> = vec![];
    for i in 0..len{
        s.push( i*2+10 );
    }

    // размер arr неизвестен на этапе компиляции но известен на этапе выполнения
    let arr: Box<[usize]> = s.into_boxed_slice();
    do_some_with_slice(arr);
}

fn do_some_with_slice(v: Box<[usize]>){
    // работаем c v. На этапе компиляции размера v мы не знаем
    // на этапе выполнения мы его можем получить:
    println!("v size={}", v.len());
}

//----------------------------------------------------------



//-------------------------- пример 2 ---------------------

// Оперировать большим обьектом в стеке - расточительно дорого
fn stack_big_obj_operate(){
    let arr = [0u8; 1024*1024];

    //тут будет копирование 1мб (если оптимизатор не выбросит)
    let arr2 = do_some_with_arr(arr);

}

fn do_some_with_arr(data: [u8; 1024*1024]) -> [u8; 5*1024*1024] {
    let result = [0; 5*1024*1024];

    //тут будет копирование 5мб (если оптимизатор не выбросит) в ту переменную, которая присвавается
    //в вызывающей функции
    result
}


// Такие большие обьекты надо завернуть в бокс, тогда их передача, присваивание будут быстррыми
fn boxed_big_obj(){
    let a = Box::new([0u8; 1024*1024]);
    let b = do_some_with_boxed_arr(a);
}

fn do_some_with_boxed_arr(x: Box<[u8; 1024*1024]>)-> Box<[u32; 1024*1024]> {
    Box::new([0u32; 1024*1024])
}
//----------------------------------------------------------


//-------------------------- пример 3 ---------------------
//Без кучи создать связанную цепочку обьектов не получится, потому что рамер такого обьекта
//неизвестен на этапе компиляции
struct Chain { next: Option<Box<Chain>> }

fn chain(len: usize) -> Box<Chain> {
    let mut prev = Box::new( Chain{next: None} );

    for _ in 0..len {
        prev = Box::new(Chain{next: Some(prev)});
    }

    prev

}
//---------------------------------------------------------


//-------------------------- пример 3 ---------------------
// Числа фибоначчи - в которой первые два числа равны либо 1 и 1, либо 0 и 1, а каждое последующее
// число равно сумме двух предыдущих чисел.

//функция возвращающая последовательность запрашиваемой длины из чисел фибоначчи

fn fib(len: usize) -> Box<[u32]> {
    let mut v = vec![];
    v.push(0);
    v.push(1);
    while v.len()<len {
        let i1 = v[v.len()-1];
        let i2 = v[v.len()-2];
        v.push(i1+i2);
    }
    v.into_boxed_slice()
}
//---------------------------------------------------------



fn main(){

}