Внимание!

Тут описано то, как понимаю я. Я могу понимать неправильно!!!
То, что написано тут - не проверялось.

Есть 3 типа барьеров:
    Relaxed
    Acquire-Release
    SeqCst


Acquire-Release = relaxed + дополнительные гарантии + дополнительное время выполнения
SeqCst = Acquire-Release + дополнительные гарантии + дополнительное время выполнения


Допустим, у нас есть две переменные: x=0, y=0 и мы пишем в них с двух потоков,
и с двух других читаем в разном порядке:

    поток 1 | поток 2 | поток 3 | поток 4
            |         |         |
    x=1     |   y=1   |         |
            |         |   a=x   |  c=y
            |         |   b=y   |  d=x

Все чтения и записи делаем с одинаковой семантикой. Все с какой-то одной. Если делать с разными - то насколько понимаю,
работать гарантии будут по самой слабой, а скорость работы будет определяться самой долгой. Поэтому, смысла нет.

Если барьеров нет, а так же с семантикой relaxed, потоки 3 и 4 увидит что угодно в любой комбинации: abcd = {допустимы 16 вариантов}

C семантикой Acquire-Release могут быть странные ситуаци:
    поток 3 увидел ab = 10 и в то же время поток 4 увидел cd = 10

Семантика SeqCst говорит нам:
    если мы увидели ab=10, то в cd мы НЕ увидим 10, а увидим или 01, или 11.

----------------------------------------------------------------------------------------------------------

И возникает вопрос. Если взять эту странную ситуацию, и все остальные возможные, то получится что
там можно увидеть все комбинации, как и в случае с relaxed и без барьеров. Тогда нахрена это все?
А это влияет на то, как ты увидишь записи, которые были до записи с барьером:


    поток 1             | поток 2
                        |
    без барьера x = 1   |
    с барьером  y = 1   |
                        |  с барьером  a = y
                        |  без барьера b = x


Тут у нас с барьером чтение и запись только в "у". А чтение и запись "х" у нас без барьеров.
Тогда:

    С семантикой relaxed можно поймать странную ситуацию ab = 10 (и остальные не странные: 00, 01, 11)
    С семантикой AcquireRelease можно увидеть: ab = 00, 11, 01. При этом 10 уже не увидишь.

----------------------------------------------------------------------------------------------------------
Возникает вопрос - а нахрена тогда нужна relaxed? Ведь с ней можно поймать все возможные варианты

А она нужна для атомарных Swap и CAS (compare and swap)

допустим, a=1, b=2, z=0

       поток 1    |  поток 2
                  |
     swap(&a, &z) | swap(&b, &z)
     print(a)     | print(b)

 без барьеров возможно ab=00. z будет равно 1 или 2. В том числе, возможна ситуация, когда
 поток 1 видит z=1, а поток 2 увидит z = 2, а через какое-то время один из потоков начнет видет то же, что и другой.
 (Почему-то мне кажется, что на х86, разные значения не увидеть. Но ab=00 возможно)
 Т.е, swap не будет атомарным.

 C семантикой relaxed ab=00 невозможно:
     если ab=01, то z будет равно 2. А если мы в z увидели 2 - это значит, что ab=01
     если ab=20, то z будет равно 1. А если мы в z увидели 1 - это значит, что ab=20

 При этом, предыдущие и последующие операции с другими переменными мы увидим
 в другом потоке переупорядоченными как угодно. Никаких гарантий нет.


volatile в java работает в семантике SeqCst

если захочется проверить, то лучше всего проверять на системах с несколькими процессорами, т.к. в этом
случае обостряется чувствительность к глюкам. Когда оно работает на нескольких ядрах одного процессора, то поймать
многие эффекты, насколько понимаю, сложней (но не невозможно).