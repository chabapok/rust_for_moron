/*
Замыкания - по большей части разновидность трейтов (бывают исключения).

1. В чем отличие записи:

    let a = 5;
    let f = || { println!("{}", a)};

от записи c move:

    let f = move || { println!("{}", a)};

ответ: в первом случае замыкание захватывает &a, во втором случае замыкание
переносит или копирует a внутрь замыкания.

2. Виды замыканий:
FnOnce() - вызывается однократно и уничтожается
FnMut() - вызывается многократно и может что-то менять.
Fn() - вызывается многократно и не может ничего менять.

Отсюда сделует правила:
 - ссылка на FnOnce() относительно бесполезна, потому что обьект, переданый по ссылке, нельзя
    уничтожить.
 - ссылка на FnMut должна быть мутабельной. И ссылка на ссылку тоже. Никакое
    &&mut FnMut() не сработает, (у меня не вышло)

3. Передача и возврат замыканий. Следует напомнить, что замыкания - это трейты,
поэтому на них распространяются все правила, которые распространяются для трейтов.

Можно обходится без стека, и этот способ достаточно хорош, но только если вообще подходит

    fn foo(v: &Fn()){....}

    fn bar() {
        foo(&||{....});
    }

К сожалению, такой способ годится не на все случаи жизни.

Можно параметризировать:
    fn foo<F: Fn()>(v: F){....}

    fn bar() {
        foo(||{....});
    }

Это более универсально, но (НЯМС) для каждого вызова это сгенерирует свой код функции foo.
Работать это будет быстрей предыдущего способа, но памяти займет больше.

Можно обернуть в Box, или Rc
    fn foo<>(v: Box<Fn()>){....}

    fn bar() {
        foo(Box::new(||{....}));
    }
Это будет дергать стек, но способ самый универсальный. Правда, с FnOnce это прокатит
только в ночной сборке (но есть crate boxfnonce)



*/