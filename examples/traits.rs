/*
Все, что касается работы с трейтами


Первое, о чем надо сказать, замыкания - это особые трейты. Это значит,
на замыкания распространяются те же правила, плюс есть свои, специфичные только для замыканий.
Сами замыкания рассмотрим в главе про замыкания.


Допустим у нас есть трейт

trait TFoo {
    fn my_cool_func(&self);
}

//--------------------------------------------------------------------------------------------------
Передача трейта в функцию. Это можно сделать тремя способами:

Способ 1 - параметризация

fn foo<T: TFoo>(v:T) { ... }


Этот способ "под капотом" принимает не трейт-обьект, а конкретный обьект. Поэтому, функция
будет реализована для каждого обьекта отдельно.

то же самое, но в более размашистом синтаксисе:

fn foo<T>(v: T) where T: TFoo { ... }

Недостатки - это раздувает код.
Достоинство - обьекты передаются через стек (в большинстве случаев, обьекты небольшие.
Если обьект будет достаточно большой, то это будет недостатком). Работа с обьектом
осуществляется не через vTable - это немножко быстрей.


Способ 2 - передача вместе с владением через кучу

Как было написано в главе про кучу, если размер обьекта неизвестен на этапе компиляции, то
его можно передавать через кучу. Выглядит это так:

fn foo(v: Box<TFoo>) { ... }

недостаток - обьект нужно отправлять в кучу, задействуя аллокатор. Это работает медленей
других способов. Кроме этого, сама работа с обьектом идет через vTable, это тоже чуть медленей,
чем в способе 1.

достоинства - универсальность.


Способ 3 - передача ссылки

Если функция, в которую надо передать трейт, может не заниматься его уничтожением, то можно
передавать ссылку:

fn foo(v: &TFoo) { ... }

Недостатки:
 - мы не можем сохранить надолго такой трейт. Как только мы захотим его добавить
в структуру - понадобися указать время жизни, а времена жизни любят вирусно распространяться
по все программе, и в результате это тяжело поддерживать.
 - вызовы происходят с помощью vtable

Достоинства - не дергается куча.

На практике этот способ удобен, чтобы передать каллбэк, который должен вызваться, но не должен
сохраняться в структуры.

//--------------------------------------------------------------------------------------------------
Возврат трейтов

Способ 1 - параметризацией

fn foo<R: TFoo>() -> R { ... }

достоинства и недостатки - те же, что и способ 1-передача трейта.
Недостаток - с замыканиями так не получается сделать.

способ 2 - через Box

fn foo() -> Box<TFoo> { ... }

достоинства и недостатки - те же, что и при передаче трейта

Способ 3 - возврат ссылки на ранее сохраненный трейт

fn foo(&self) -> &TFoo { ... }

Тут наверное некорректно говорить о достоинствах и недостатках, это больше специфичный способ,
применение которого вытекает не из достоинств и недостатков - а из соображений организации логики.

//--------------------------------------------------------------------------------------------------

Использование ограничений типажей высшего порядка ОТВП (HRTB, for<'a>)

жуть, ад, необьяснимая хрень, это непостижимо.

*/