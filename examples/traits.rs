/*
Все, что касается работы с трейтами


Первое, о чем надо сказать, замыкания - это особые трейты. Это значит,
на замыкания распространяются те же правила, что и для трейтов, плюс есть свои,
специфичные только для замыканий.
Сами замыкания рассмотрим в главе про замыкания. Там же рассмотрено, что можно делать с замыканиями.


Допустим у нас есть трейт

trait TFoo {
    fn my_cool_func(&self);
}

//--------------------------------------------------------------------------------------------------
Передача трейта в функцию. Это можно сделать тремя способами:

Способ 1 - параметризация

fn foo<T: TFoo>(v:T) { ... }


Этот способ "под капотом" принимает не трейт-обьект, а конкретный обьект. Поэтому, функция
будет реализована для каждого обьекта отдельно.

то же самое, но в более размашистом синтаксисе:

fn foo<T>(v: T) where T: TFoo { ... }

Недостатки - это раздувает код.
Достоинство - обьекты передаются через стек (в большинстве случаев, обьекты небольшие.
Если обьект будет достаточно большой, то это будет недостатком). Работа с обьектом
осуществляется не через vTable - это немножко быстрей.


Способ 2 - передача вместе с владением через кучу

Как было написано в главе про кучу, если размер обьекта неизвестен на этапе компиляции, то
его можно передавать через кучу. Выглядит это так:

fn foo(v: Box<TFoo>) { ... }

недостаток - при создании обьект нужно отправлять в кучу, задействуя аллокатор. Это работает медленей
других способов. Кроме этого, сама работа с обьектом идет через vTable, это тоже чуть медленей,
чем в способе 1.

достоинства - универсальность. Таким же методом можно передавать не только Box<TFoo>, но и
любой указатель на кучу: Rc<TFoo>, Weak<TFoo> (но Vec<TFoo> все же нельзя)


Способ 3 - передача ссылки

Если функция, в которую надо передать трейт, может не заниматься его уничтожением, то можно
передавать ссылку:

fn foo(v: &TFoo) { ... }

Недостатки:
 - "надолго" такой трейт сохранять - боль. Как только мы захотим его добавить
в структуру - понадобися указать время жизни, а времена жизни любят вирусно распространяться
по все программе, и в результате это тяжело поддерживать.
 - вызовы происходят с помощью vtable
Достоинства:
 - не дергается куча.

На практике этот способ удобен, чтобы передать каллбэк, который должен вызваться, но не должен
сохраняться в структуры.

//--------------------------------------------------------------------------------------------------
Возврат трейтов

Способ 1 - ассоциированным типом
        trait MyTarit {
            type R;
            fn foo()->R;
        }

        struct Bar;

        impl MyTrait for ... {
           type R = Bar
           fn foo()->Bar { ... }
        }

Примечание 1. Вот так написать не получится: fn foo<R: TFoo>() -> R { ... }
Примечание 2: в ночнике есть способ сделать это.

способ 2 - через Box

        fn foo() -> Box<TFoo> { ... }

Способ 3 - возврат ссылки на ранее сохраненный трейт

        fn foo(&self) -> &TFoo { ... }

Тут наверное некорректно говорить о достоинствах и недостатках, это больше специфичный способ,
применение которого вытекает не из достоинств и недостатков - а из соображений организации логики.

//--------------------------------------------------------------------------------------------------
Приведение трейтов.

Структуру, если для нее реализован трейт TFoo можно привести к этому трейту. А именно.
Допустим, у нас есть:
    struct Foo;
    impl TFoo for Foo{...}

Тогда:
    - ссылки &Foo и &mut foo автоматически приводится при надобности к &TFoo &mut TFoo.
    - При помощи as можно Box<Foo> привести к Box<TFoo>, то же самое с Rc и Weak
    - приведение одного трейта к другому компилятор делать не умеет. :(


//--------------------------------------------------------------------------------------------------

Использование ограничений типажей высшего порядка ОТВП (HRTB, for<'a>)

трэш, угар, жуть, ад, содомия, необьяснимая хрень, это непостижимо.


*/


//интересный пример 1 - приветедние к трейтам
trait TA{ }
trait TB{ }

//аналог наследования трейтов. "хочешь ТС - реализуй и ТА тоже"
trait TC: TA { }

//реализовать TB для всех, кто реализует TA
impl <T:TA> TB for T {}

fn foo1<X: TA+'static>(v: Box<X>) {
    let a = v as Box<TB+'static>;
}

fn foo2<X: TC+'static>(v: Box<X>) {
    let a = v as Box<TA+'static>;
}

//если из ТС можно сделать TA, и из TA сделать TB - то
//из TC можно сделать TB
fn foo4<X: TC+'static>(v: Box<X>) {
    let a = v as Box<TB+'static>;
}

//Однако же, TB можно реализовать и для кого-нибудь,
//кто НЕ реализует TA. поэтому в обратную сторону не получится:
fn foo3<X: TB+'static>(v: Box<X>) {
    //    let a = v as Box<TA+'static>; //ошибка
}


fn main() {

}